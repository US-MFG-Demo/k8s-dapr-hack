# Assignment 8 - Deploy to Azure Kubernetes Service (AKS)

In this assignment, you're going to deploy the Dapr-enabled services you have written locally to an [Azure Kubernetes Service (AKS)](https://docs.microsoft.com/en-us/azure/aks/) cluster.

![architecture](./img/architecture.png)

## Assignment goals

To complete this assignment, you must reach the following goals:

- Successfully deploy all 3 services (VehicleRegistrationService, TrafficControlService & FineCollectionService) to an AKS cluster.
- Successfully run the Simulation service locally that connects to your AKS-hosted services

## Step 1: Update all port numbers

By default, Dapr sidecars run on port 3500 when deployed to AKS. This means you will need to change the port numbers in the FineCollectionService & TrafficControlService to port 3500 for the calls to Dapr.

- src/FineCollectionService/Proxies/VehicleRegistrationService.cs
- src/TrafficControlService/Controllers/TrafficController.cs

## Step 2: Update the Dapr secrets configuration file to use a Managed Identity to pull secrets from Azure KeyVault

Of course, you can use a Kubernetes secret and use the same certificate file you generated in Assignment07. However, AKS can use a Managed Identity to
get access to a KeyVault. This is a more secure & supportable option since there is no file to manage & no certificate that will expire. However, at the time
of this writing, it is a preview feature. If you want to use the certificate file instead, refer to the instructions 
[here](https://docs.dapr.io/reference/components-reference/supported-secret-stores/azure-keyvault/#configure-the-component).

1.  Run the following 3 commands to grant the managed identity access to your AKS cluster. Update the **CLIENT_ID** with the managed service identity client id, 
    the **SUBSCRIPTION_ID** and the **NODE_RESOURCE_GROUP** is the **AKS Node Resource Group (auto-generated by AKS deployment, starts with MC_** not the 
    default resource group your cluster resource and the other workshop resources are deployed to.

    Note that the code below is expected to run in bash (using shell variables). If running in PowerShell, add a $ to the beginning of the variable definitions (ex. `$CLIENT_ID="de368b69-8ba7-4a29-9af4-fb513a09adf3"`).

    ```shell
    CLIENT_ID="de368b69-8ba7-4a29-9af4-fb513a09adf3"
    SUBSCRIPTION_ID="dcf66641-6312-4ee1-b296-723bb0a999ba"
    NODE_RESOURCE_GROUP_NAME="MC_rg-dapr-workshop-ussc-demo_aks-dapr-ussc-demo_southcentralus"

    az role assignment create --role "Reader" --assignee $CLIENT_ID --scope /subscriptions/$SUBSCRIPTION_ID/resourcegroups/$NODE_RESOURCE_GROUP_NAME

    az role assignment create --role "Managed Identity Operator" --assignee $CLIENT_ID --scope /subscriptions/$SUBSCRIPTION_ID/resourcegroups/$NODE_RESOURCE_GROUP_NAME

    az role assignment create --role "Virtual Machine Contributor" --assignee $CLIENT_ID --scope /subscriptions/$SUBSCRIPTION_ID/resourcegroups/$NODE_RESOURCE_GROUP_NAME
    ```

1.  Update the ```src/dapr/components/secrets-file.yaml``` with the Azure KeyVault configuration values. You will need to customize the 
    **KeyVault name**, **client ID**, **resource ID**.

    ```yaml
    apiVersion: dapr.io/v1alpha1
    kind: Component
    metadata:
      name: trafficcontrol-secrets
    spec:
      type: secretstores.azure.keyvault
      version: v1
      metadata:
      - name: vaultName
        value: kv-dapr-ussc-demo
      - name: spnClientId
        value: de368b69-8ba7-4a29-9af4-fb513a09adf3
      - name: nestedSeparator
        value: "-"
    scopes:
    - finecollectionservice   

    ---
    apiVersion: "aadpodidentity.k8s.io/v1"
    kind: AzureIdentity
    metadata:
      name: mi-aks-dapr-ussc-demo
    spec:
      type: 0
      resourceID: /subscriptions/dcf66641-6312-4ee1-b296-723bb0a999ba/resourceGroups/rg-dapr-workshop-ussc-demo/providers/Microsoft.ManagedIdentity/userAssignedIdentities/mi-aks-dapr-ussc-demo
      clientID: de368b69-8ba7-4a29-9af4-fb513a09adf3

    ---
    apiVersion: "aadpodidentity.k8s.io/v1"
    kind: AzureIdentityBinding
    metadata:
      name: mi-aks-dapr-ussc-demo-identity-binding
    spec:
      azureIdentity: mi-aks-dapr-ussc-demo
      selector: dapr-workshop-aad-id
    ```

## Step 3: Build container images for each service & upload to Azure Container Registry

You will need to build these services, create a Docker container image that has this source code baked into it and then upload
to an Azure Container Registry. The easiest way to do that is to use [ACR tasks](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-tasks-overview).

1. 	Navigate to the src/VehicleRegistrationService directory & use the Azure Container Registry task to build your image from source.

    ```shell
    az acr build --registry <container-registry-name> --image vehicleregistrationservice:assignment08 .
    ```

1. 	Navigate to the src/TrafficControlService directory & use the Azure Container Registry task to build your image from source.

    ```shell
    az acr build --registry <container-registry-name> --image trafficcontrolservice:assignment08 .
    ```

1. 	Navigate to the src/FineCollectionService directory & use the Azure Container Registry task to build your image from source.
  
    ```shell
    az acr build --registry <container-registry-name> --image trafficcontrolservice:assignment08 .		
    ```

## Step 4: Deploy container images to Azure Kubernetes Service

Now that your container images have been uploaded to the Azure Container Registry, you can deploy these images to your Azure
Kubernetes Service. Deployment spec files have been added to each service to make this easier. You will need to customize them
to reference your container registry path & AKS ingress.

1.	Open the `src/FineCollectionService/deploy/deploy.yaml` file and update the container registry name to be the one you have deployed.

    ```yaml
    spec:
      containers:
      - name: finecollectionservice
        image: <container-registry-name>.azurecr.io/finecollectionservice:assignment08
    ```

1.	Modify the ingress host to match your AKS instance's HTTP application routing domain. You can query for this if you don't have it.

    ```shell
    az aks show --resource-group <resource-group-name> --name <aks-name> --query="addonProfiles.httpApplicationRouting.config.HTTPApplicationRoutingZoneName"
    ```

    ```shell
    "e13e6fb6d2534a41ae60.southcentralus.aksapp.io"
    ```

    ```yaml
    spec:
    rules:
    - host: finecollectionservice.<aks-http-application-routing-zone-name>
    ```
    
    Repeat these steps for the `TrafficControlService` and the `VehicleRegistrationService`.

1. 	Deploy your new services to AKS. From the root of each service's application code directory, run the following.

    ```shell
    kubectl apply -f ./deploy/deploy.yaml
    ```

    Repeat these steps for the `TrafficControlService` and the `VehicleRegistrationService`.

1.	Verify your services are running (it may take a little while for all the services to finish starting up). You may see
		a few different pods running in the default namespace in addition to your services (and the unique identifiers on the
		end of the services will be different).

    ```shell
    kubectl get pods
    ```

    ```shell
    NAME                                          READY   STATUS             RESTARTS   AGE  
    finecollectionservice-7f76f68547-d98gc        2/2     Running            0          4d18h
    trafficcontrolservice-749ffcf4bb-crx54        2/2     Running            0          4d19h
    vehicleregistrationservice-65c9cf6cdc-s7c4s   2/2     Running            0          4d19h
    ```

## Step 5: Deploy Dapr sidecars to Azure Kubernetes Service

Run the following command to deploy all of your Dapr sidecars to AKS.

```
cd src/dapr/components
kubectl apply -f .
```

## Step 6: Run Simulation application

Run the Simluation service, which writes to your IoT Hub's MQTT queue. You will begin to see fines get emailed to you as
appropriate.

## Final solution

You have reached the end of the hands-on assignments. If you haven't been able to do all the assignments, go to this [this repository](https://github.com/edwinvw/dapr-traffic-control) for the end result.

Thanks for participating in these hands-on assignments! Hopefully you've learned about Dapr and how to use it. Obviously, these assignment barely scratch the surface of what is possible with Dapr. We have not touched upon subjects like: hardening production environments, actors, integration with Azure Functions, Azure API Management and Azure Logic Apps just to name a few. So if you're interested in learning more, I suggest you read the [Dapr documentation](https://docs.dapr.io).